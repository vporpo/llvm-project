; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 2
; RUN: opt -passes=sandbox-vectorizer -sbvec-vec-reg-bits=512 -sbvec-cost-threshold=-9999 %s -S | FileCheck %s --check-prefix=VECTOR
; RUN: opt -passes=sandbox-vectorizer -sbvec-vec-reg-bits=512 -sbvec-cost-threshold=99999 %s -S | FileCheck %s --check-prefix=SCALAR

define void @widen_cmps(ptr %ptrA, ptr %ptrB, ptr %ptrC) {
; VECTOR-LABEL: define void @widen_cmps
; VECTOR-SAME: (ptr [[PTRA:%.*]], ptr [[PTRB:%.*]], ptr [[PTRC:%.*]]) {
; VECTOR-NEXT:    [[PTRA0:%.*]] = getelementptr float, ptr [[PTRA]], i32 0
; VECTOR-NEXT:    [[PTRB0:%.*]] = getelementptr float, ptr [[PTRB]], i32 0
; VECTOR-NEXT:    [[PTRC0:%.*]] = getelementptr i64, ptr [[PTRC]], i32 0
; VECTOR-NEXT:    [[VECL1:%.*]] = load <2 x float>, ptr [[PTRA0]], align 4
; VECTOR-NEXT:    [[VECL2:%.*]] = load <2 x float>, ptr [[PTRB0]], align 4
; VECTOR-NEXT:    [[VECL:%.*]] = load <2 x i64>, ptr [[PTRC0]], align 4
; VECTOR-NEXT:    [[VCMP:%.*]] = icmp slt <2 x i64> [[VECL]], <i64 0, i64 1>
; VECTOR-NEXT:    [[VEC:%.*]] = select <2 x i1> [[VCMP]], <2 x float> [[VECL1]], <2 x float> [[VECL2]]
; VECTOR-NEXT:    store <2 x float> [[VEC]], ptr [[PTRA0]], align 4
; VECTOR-NEXT:    ret void
;
; SCALAR-LABEL: define void @widen_cmps
; SCALAR-SAME: (ptr [[PTRA:%.*]], ptr [[PTRB:%.*]], ptr [[PTRC:%.*]]) {
; SCALAR-NEXT:    [[PTRA0:%.*]] = getelementptr float, ptr [[PTRA]], i32 0
; SCALAR-NEXT:    [[PTRA1:%.*]] = getelementptr float, ptr [[PTRA]], i32 1
; SCALAR-NEXT:    [[PTRB0:%.*]] = getelementptr float, ptr [[PTRB]], i32 0
; SCALAR-NEXT:    [[PTRB1:%.*]] = getelementptr float, ptr [[PTRB]], i32 1
; SCALAR-NEXT:    [[PTRC0:%.*]] = getelementptr i64, ptr [[PTRC]], i32 0
; SCALAR-NEXT:    [[PTRC1:%.*]] = getelementptr i64, ptr [[PTRC]], i32 1
; SCALAR-NEXT:    [[LDA0:%.*]] = load float, ptr [[PTRA0]], align 4
; SCALAR-NEXT:    [[LDA1:%.*]] = load float, ptr [[PTRA1]], align 4
; SCALAR-NEXT:    [[LDB0:%.*]] = load float, ptr [[PTRB0]], align 4
; SCALAR-NEXT:    [[LDB1:%.*]] = load float, ptr [[PTRB1]], align 4
; SCALAR-NEXT:    [[LDC0:%.*]] = load i64, ptr [[PTRC0]], align 4
; SCALAR-NEXT:    [[LDC1:%.*]] = load i64, ptr [[PTRC1]], align 4
; SCALAR-NEXT:    [[CMP0:%.*]] = icmp slt i64 [[LDC0]], 0
; SCALAR-NEXT:    [[CMP1:%.*]] = icmp slt i64 [[LDC1]], 1
; SCALAR-NEXT:    [[SEL0:%.*]] = select i1 [[CMP0]], float [[LDA0]], float [[LDB0]]
; SCALAR-NEXT:    [[SEL1:%.*]] = select i1 [[CMP1]], float [[LDA1]], float [[LDB1]]
; SCALAR-NEXT:    store float [[SEL0]], ptr [[PTRA0]], align 4
; SCALAR-NEXT:    store float [[SEL1]], ptr [[PTRA1]], align 4
; SCALAR-NEXT:    ret void
;
  %ptrA0 = getelementptr float, ptr %ptrA, i32 0
  %ptrA1 = getelementptr float, ptr %ptrA, i32 1
  %ptrB0 = getelementptr float, ptr %ptrB, i32 0
  %ptrB1 = getelementptr float, ptr %ptrB, i32 1
  %ptrC0 = getelementptr i64, ptr %ptrC, i32 0
  %ptrC1 = getelementptr i64, ptr %ptrC, i32 1

  %ldA0 = load float, ptr %ptrA0
  %ldA1 = load float, ptr %ptrA1

  %ldB0 = load float, ptr %ptrB0
  %ldB1 = load float, ptr %ptrB1

  %ldC0 = load i64, ptr %ptrC0
  %ldC1 = load i64, ptr %ptrC1

  %cmp0 = icmp slt i64 %ldC0, 0
  %cmp1 = icmp slt i64 %ldC1, 1

  %sel0 = select i1 %cmp0, float %ldA0, float %ldB0
  %sel1 = select i1 %cmp1, float %ldA1, float %ldB1

  store float %sel0, ptr %ptrA0
  store float %sel1, ptr %ptrA1
  ret void
}

define void @dont_widen_cmps_with_different_operand_types(ptr %ptrA, ptr %ptrB) {
; VECTOR-LABEL: define void @dont_widen_cmps_with_different_operand_types
; VECTOR-SAME: (ptr [[PTRA:%.*]], ptr [[PTRB:%.*]]) {
; VECTOR-NEXT:    [[PTRA0:%.*]] = getelementptr float, ptr [[PTRA]], i32 0
; VECTOR-NEXT:    [[PTRB0:%.*]] = getelementptr i64, ptr [[PTRB]], i32 0
; VECTOR-NEXT:    [[PTRB1:%.*]] = getelementptr i32, ptr [[PTRB]], i32 2
; VECTOR-NEXT:    [[VECL:%.*]] = load <2 x float>, ptr [[PTRA0]], align 4
; VECTOR-NEXT:    [[LDB0:%.*]] = load i32, ptr [[PTRB0]], align 4
; VECTOR-NEXT:    [[LDB1:%.*]] = load i64, ptr [[PTRB1]], align 4
; VECTOR-NEXT:    [[CMP0:%.*]] = icmp slt i32 [[LDB0]], 0
; VECTOR-NEXT:    [[CMP1:%.*]] = icmp slt i64 [[LDB1]], 1
; VECTOR-NEXT:    [[PACK:%.*]] = insertelement <2 x i1> poison, i1 [[CMP0]], i64 0
; VECTOR-NEXT:    [[PACK1:%.*]] = insertelement <2 x i1> [[PACK]], i1 [[CMP1]], i64 1
; VECTOR-NEXT:    [[VEC:%.*]] = select <2 x i1> [[PACK1]], <2 x float> [[VECL]], <2 x float> [[VECL]]
; VECTOR-NEXT:    store <2 x float> [[VEC]], ptr [[PTRA0]], align 4
; VECTOR-NEXT:    ret void
;
; SCALAR-LABEL: define void @dont_widen_cmps_with_different_operand_types
; SCALAR-SAME: (ptr [[PTRA:%.*]], ptr [[PTRB:%.*]]) {
; SCALAR-NEXT:    [[PTRA0:%.*]] = getelementptr float, ptr [[PTRA]], i32 0
; SCALAR-NEXT:    [[PTRA1:%.*]] = getelementptr float, ptr [[PTRA]], i32 1
; SCALAR-NEXT:    [[PTRB0:%.*]] = getelementptr i64, ptr [[PTRB]], i32 0
; SCALAR-NEXT:    [[PTRB1:%.*]] = getelementptr i32, ptr [[PTRB]], i32 2
; SCALAR-NEXT:    [[LDA0:%.*]] = load float, ptr [[PTRA0]], align 4
; SCALAR-NEXT:    [[LDA1:%.*]] = load float, ptr [[PTRA1]], align 4
; SCALAR-NEXT:    [[LDB0:%.*]] = load i32, ptr [[PTRB0]], align 4
; SCALAR-NEXT:    [[LDB1:%.*]] = load i64, ptr [[PTRB1]], align 4
; SCALAR-NEXT:    [[CMP0:%.*]] = icmp slt i32 [[LDB0]], 0
; SCALAR-NEXT:    [[CMP1:%.*]] = icmp slt i64 [[LDB1]], 1
; SCALAR-NEXT:    [[SEL0:%.*]] = select i1 [[CMP0]], float [[LDA0]], float [[LDA0]]
; SCALAR-NEXT:    [[SEL1:%.*]] = select i1 [[CMP1]], float [[LDA1]], float [[LDA1]]
; SCALAR-NEXT:    store float [[SEL0]], ptr [[PTRA0]], align 4
; SCALAR-NEXT:    store float [[SEL1]], ptr [[PTRA1]], align 4
; SCALAR-NEXT:    ret void
;
  %ptrA0 = getelementptr float, ptr %ptrA, i32 0
  %ptrA1 = getelementptr float, ptr %ptrA, i32 1
  %ptrB0 = getelementptr i64, ptr %ptrB, i32 0
  %ptrB1 = getelementptr i32, ptr %ptrB, i32 2

  %ldA0 = load float, ptr %ptrA0
  %ldA1 = load float, ptr %ptrA1

  %ldB0 = load i32, ptr %ptrB0
  %ldB1 = load i64, ptr %ptrB1

  %cmp0 = icmp slt i32 %ldB0, 0
  %cmp1 = icmp slt i64 %ldB1, 1

  %sel0 = select i1 %cmp0, float %ldA0, float %ldA0
  %sel1 = select i1 %cmp1, float %ldA1, float %ldA1

  store float %sel0, ptr %ptrA0
  store float %sel1, ptr %ptrA1
  ret void
}
