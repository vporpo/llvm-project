; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 3
; RUN: opt -passes=sandbox-vectorizer -sbvec-vec-reg-bits=512 -sbvec-cost-threshold=-9999 %s -sbvec-passes=vectorize-packs -S | FileCheck %s --check-prefix=VECTOR
; RUN: opt -passes=sandbox-vectorizer -sbvec-vec-reg-bits=512 -sbvec-cost-threshold=99999 %s -sbvec-passes=vectorize-packs -S | FileCheck %s --check-prefix=SCALAR

; When we vectorize the operands of a Pack and the result is a vector value
; with the same number of lanes as the Pack, then we no longer need the Pack.
; This should rarely happen in practice.
define void @vectorize_packs_perfect_match(ptr noalias %ptr) {
;
; VECTOR-LABEL: define void @vectorize_packs_perfect_match(
; VECTOR-SAME: ptr noalias [[PTR:%.*]]) {
; VECTOR-NEXT:    [[PTR0:%.*]] = getelementptr float, ptr [[PTR]], i32 0
; VECTOR-NEXT:    [[VECL:%.*]] = load <3 x float>, ptr [[PTR0]], align 4
; VECTOR-NEXT:    [[UNPACK1:%.*]] = shufflevector <3 x float> [[VECL]], <3 x float> poison, <2 x i32> <i32 1, i32 2>
; VECTOR-NEXT:    [[UNPACK:%.*]] = extractelement <3 x float> [[VECL]], i64 0
; VECTOR-NEXT:    store <3 x float> [[VECL]], ptr [[PTR]], align 16
; VECTOR-NEXT:    ret void
;
; SCALAR-LABEL: define void @vectorize_packs_perfect_match(
; SCALAR-SAME: ptr noalias [[PTR:%.*]]) {
; SCALAR-NEXT:    [[PTR0:%.*]] = getelementptr float, ptr [[PTR]], i32 0
; SCALAR-NEXT:    [[PTR1:%.*]] = getelementptr float, ptr [[PTR]], i32 1
; SCALAR-NEXT:    [[LD0:%.*]] = load float, ptr [[PTR0]], align 4
; SCALAR-NEXT:    [[LD1:%.*]] = load <2 x float>, ptr [[PTR1]], align 8
; SCALAR-NEXT:    [[INS0:%.*]] = insertelement <3 x float> poison, float [[LD0]], i32 0
; SCALAR-NEXT:    [[EXTR0:%.*]] = extractelement <2 x float> [[LD1]], i32 0
; SCALAR-NEXT:    [[INS1:%.*]] = insertelement <3 x float> [[INS0]], float [[EXTR0]], i32 1
; SCALAR-NEXT:    [[EXTR1:%.*]] = extractelement <2 x float> [[LD1]], i32 1
; SCALAR-NEXT:    [[INS2:%.*]] = insertelement <3 x float> [[INS1]], float [[EXTR1]], i32 2
; SCALAR-NEXT:    store <3 x float> [[INS2]], ptr [[PTR]], align 16
; SCALAR-NEXT:    ret void
;
  %ptr0 = getelementptr float, ptr %ptr, i32 0, !sb !0
  %ptr1 = getelementptr float, ptr %ptr, i32 1, !sb !0
  %ld0 = load float, ptr %ptr0, !sb !0
  %ld1 = load <2 x float>, ptr %ptr1, !sb !0

  %ins0 = insertelement <3 x float> poison, float %ld0, i32 0, !sb !0

  %extr0 = extractelement <2 x float> %ld1, i32 0, !sb !0
  %ins1 = insertelement <3 x float> %ins0, float %extr0, i32 1, !sb !0
  %extr1 = extractelement <2 x float> %ld1, i32 1, !sb !0
  %ins2 = insertelement <3 x float> %ins1, float %extr1, i32 2, !sb !0

  store <3 x float> %ins2, ptr %ptr, !sb !0
  ret void
}

!0 = !{!"region", i32 0}
