; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 3
; RUN: opt -passes=sandbox-vectorizer -sbvec-vec-reg-bits=512 -sbvec-cost-threshold=-9999 -sbvec-force-seeds=stores %s -S | FileCheck %s --check-prefix=VECTOR
; RUN: opt -passes=sandbox-vectorizer -sbvec-vec-reg-bits=512 -sbvec-cost-threshold=99999 -sbvec-force-seeds=stores %s -S | FileCheck %s --check-prefix=SCALAR

define void @cross_bb(ptr noalias %ptr) {
;
; VECTOR-LABEL: define void @cross_bb(
; VECTOR-SAME: ptr noalias [[PTR:%.*]]) {
; VECTOR-NEXT:  bb0:
; VECTOR-NEXT:    [[PTR0:%.*]] = getelementptr float, ptr [[PTR]], i32 0
; VECTOR-NEXT:    [[PTR1:%.*]] = getelementptr float, ptr [[PTR]], i32 1
; VECTOR-NEXT:    [[LD0:%.*]] = load float, ptr [[PTR0]], align 4
; VECTOR-NEXT:    [[LD1:%.*]] = load float, ptr [[PTR1]], align 4
; VECTOR-NEXT:    br label [[BB1:%.*]]
; VECTOR:       bb1:
; VECTOR-NEXT:    [[PACK:%.*]] = insertelement <2 x float> poison, float [[LD0]], i64 0
; VECTOR-NEXT:    [[PACK1:%.*]] = insertelement <2 x float> [[PACK]], float [[LD1]], i64 1
; VECTOR-NEXT:    store <2 x float> [[PACK1]], ptr [[PTR0]], align 4
; VECTOR-NEXT:    ret void
;
; SCALAR-LABEL: define void @cross_bb(
; SCALAR-SAME: ptr noalias [[PTR:%.*]]) {
; SCALAR-NEXT:  bb0:
; SCALAR-NEXT:    [[PTR0:%.*]] = getelementptr float, ptr [[PTR]], i32 0
; SCALAR-NEXT:    [[PTR1:%.*]] = getelementptr float, ptr [[PTR]], i32 1
; SCALAR-NEXT:    [[LD0:%.*]] = load float, ptr [[PTR0]], align 4
; SCALAR-NEXT:    [[LD1:%.*]] = load float, ptr [[PTR1]], align 4
; SCALAR-NEXT:    br label [[BB1:%.*]]
; SCALAR:       bb1:
; SCALAR-NEXT:    store float [[LD0]], ptr [[PTR0]], align 4
; SCALAR-NEXT:    store float [[LD1]], ptr [[PTR1]], align 4
; SCALAR-NEXT:    ret void
;
bb0:
  %ptr0 = getelementptr float, ptr %ptr, i32 0
  %ptr1 = getelementptr float, ptr %ptr, i32 1
  %ld0 = load float, ptr %ptr0
  %ld1 = load float, ptr %ptr1
  br label %bb1

bb1:
  store float %ld0, ptr %ptr0
  store float %ld1, ptr %ptr1
  ret void
}

define void @cross_bb_with_phi(ptr noalias %ptr) {
;
; VECTOR-LABEL: define void @cross_bb_with_phi(
; VECTOR-SAME: ptr noalias [[PTR:%.*]]) {
; VECTOR-NEXT:  bb0:
; VECTOR-NEXT:    [[PTR0:%.*]] = getelementptr float, ptr [[PTR]], i32 0
; VECTOR-NEXT:    [[PTR1:%.*]] = getelementptr float, ptr [[PTR]], i32 1
; VECTOR-NEXT:    [[LD0:%.*]] = load float, ptr [[PTR0]], align 4
; VECTOR-NEXT:    [[LD1:%.*]] = load float, ptr [[PTR1]], align 4
; VECTOR-NEXT:    br label [[BB1:%.*]]
; VECTOR:       bb1:
; VECTOR-NEXT:    [[PHI:%.*]] = phi i32 [ 0, [[BB0:%.*]] ], [ 1, [[BB1]] ]
; VECTOR-NEXT:    [[PACK:%.*]] = insertelement <2 x float> poison, float [[LD0]], i64 0
; VECTOR-NEXT:    [[PACK1:%.*]] = insertelement <2 x float> [[PACK]], float [[LD1]], i64 1
; VECTOR-NEXT:    store <2 x float> [[PACK1]], ptr [[PTR0]], align 4
; VECTOR-NEXT:    br label [[BB1]]
;
; SCALAR-LABEL: define void @cross_bb_with_phi(
; SCALAR-SAME: ptr noalias [[PTR:%.*]]) {
; SCALAR-NEXT:  bb0:
; SCALAR-NEXT:    [[PTR0:%.*]] = getelementptr float, ptr [[PTR]], i32 0
; SCALAR-NEXT:    [[PTR1:%.*]] = getelementptr float, ptr [[PTR]], i32 1
; SCALAR-NEXT:    [[LD0:%.*]] = load float, ptr [[PTR0]], align 4
; SCALAR-NEXT:    [[LD1:%.*]] = load float, ptr [[PTR1]], align 4
; SCALAR-NEXT:    br label [[BB1:%.*]]
; SCALAR:       bb1:
; SCALAR-NEXT:    [[PHI:%.*]] = phi i32 [ 0, [[BB0:%.*]] ], [ 1, [[BB1]] ]
; SCALAR-NEXT:    store float [[LD0]], ptr [[PTR0]], align 4
; SCALAR-NEXT:    store float [[LD1]], ptr [[PTR1]], align 4
; SCALAR-NEXT:    br label [[BB1]]
;
bb0:
  %ptr0 = getelementptr float, ptr %ptr, i32 0
  %ptr1 = getelementptr float, ptr %ptr, i32 1
  %ld0 = load float, ptr %ptr0
  %ld1 = load float, ptr %ptr1
  br label %bb1

bb1:
  %phi = phi i32 [ 0, %bb0 ], [ 1, %bb1 ]
  store float %ld0, ptr %ptr0
  store float %ld1, ptr %ptr1
  br label %bb1
}

