; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 3
; RUN: opt -passes=sandbox-vectorizer -sbvec-vec-reg-bits=512 -sbvec-cost-threshold=-9999 %s -S | FileCheck %s --check-prefix=VECTOR
; RUN: opt -passes=sandbox-vectorizer -sbvec-vec-reg-bits=512 -sbvec-cost-threshold=99999 %s -S | FileCheck %s --check-prefix=SCALAR

declare void @foo()

; Check that if we fail to vectorize the original seed bundle we then slice it
; and try again.
define void @slice_seeds(ptr %ptr, float %val) {
;
; VECTOR-LABEL: define void @slice_seeds(
; VECTOR-SAME: ptr [[PTR:%.*]], float [[VAL:%.*]]) {
; VECTOR-NEXT:    [[PTR0:%.*]] = getelementptr float, ptr [[PTR]], i32 0
; VECTOR-NEXT:    [[PTR1:%.*]] = getelementptr float, ptr [[PTR]], i32 1
; VECTOR-NEXT:    [[PTR2:%.*]] = getelementptr float, ptr [[PTR]], i32 2
; VECTOR-NEXT:    [[LD2:%.*]] = load float, ptr [[PTR1]], align 4
; VECTOR-NEXT:    store float [[LD2]], ptr [[PTR2]], align 4
; VECTOR-NEXT:    call void @foo()
; VECTOR-NEXT:    [[VECL:%.*]] = load <2 x float>, ptr [[PTR0]], align 4
; VECTOR-NEXT:    store <2 x float> [[VECL]], ptr [[PTR0]], align 4
; VECTOR-NEXT:    ret void
;
; SCALAR-LABEL: define void @slice_seeds(
; SCALAR-SAME: ptr [[PTR:%.*]], float [[VAL:%.*]]) {
; SCALAR-NEXT:    [[PTR0:%.*]] = getelementptr float, ptr [[PTR]], i32 0
; SCALAR-NEXT:    [[PTR1:%.*]] = getelementptr float, ptr [[PTR]], i32 1
; SCALAR-NEXT:    [[PTR2:%.*]] = getelementptr float, ptr [[PTR]], i32 2
; SCALAR-NEXT:    [[LD2:%.*]] = load float, ptr [[PTR1]], align 4
; SCALAR-NEXT:    store float [[LD2]], ptr [[PTR2]], align 4
; SCALAR-NEXT:    call void @foo()
; SCALAR-NEXT:    [[LD0:%.*]] = load float, ptr [[PTR0]], align 4
; SCALAR-NEXT:    [[LD1:%.*]] = load float, ptr [[PTR1]], align 4
; SCALAR-NEXT:    store float [[LD0]], ptr [[PTR0]], align 4
; SCALAR-NEXT:    store float [[LD1]], ptr [[PTR1]], align 4
; SCALAR-NEXT:    ret void
;
  %ptr0 = getelementptr float, ptr %ptr, i32 0
  %ptr1 = getelementptr float, ptr %ptr, i32 1
  %ptr2 = getelementptr float, ptr %ptr, i32 2

  %ld2 = load float, ptr %ptr1
  store float %ld2, ptr %ptr2
  ; This call blocks scheduling of all 3 stores.
  call void @foo()

  %ld0 = load float, ptr %ptr0
  %ld1 = load float, ptr %ptr1
  store float %ld0, ptr %ptr0
  store float %ld1, ptr %ptr1
  ret void
}

define void @slice_seeds2(ptr %ptr, float %val) {
;
; VECTOR-LABEL: define void @slice_seeds2(
; VECTOR-SAME: ptr [[PTR:%.*]], float [[VAL:%.*]]) {
; VECTOR-NEXT:    [[PTR0:%.*]] = getelementptr float, ptr [[PTR]], i32 0
; VECTOR-NEXT:    [[PTR1:%.*]] = getelementptr float, ptr [[PTR]], i32 1
; VECTOR-NEXT:    [[LD0:%.*]] = load float, ptr [[PTR0]], align 4
; VECTOR-NEXT:    store float [[LD0]], ptr [[PTR0]], align 4
; VECTOR-NEXT:    call void @foo()
; VECTOR-NEXT:    [[VECL:%.*]] = load <2 x float>, ptr [[PTR1]], align 4
; VECTOR-NEXT:    store <2 x float> [[VECL]], ptr [[PTR1]], align 4
; VECTOR-NEXT:    ret void
;
; SCALAR-LABEL: define void @slice_seeds2(
; SCALAR-SAME: ptr [[PTR:%.*]], float [[VAL:%.*]]) {
; SCALAR-NEXT:    [[PTR0:%.*]] = getelementptr float, ptr [[PTR]], i32 0
; SCALAR-NEXT:    [[PTR1:%.*]] = getelementptr float, ptr [[PTR]], i32 1
; SCALAR-NEXT:    [[PTR2:%.*]] = getelementptr float, ptr [[PTR]], i32 2
; SCALAR-NEXT:    [[LD0:%.*]] = load float, ptr [[PTR0]], align 4
; SCALAR-NEXT:    store float [[LD0]], ptr [[PTR0]], align 4
; SCALAR-NEXT:    call void @foo()
; SCALAR-NEXT:    [[LD2:%.*]] = load float, ptr [[PTR2]], align 4
; SCALAR-NEXT:    [[LD1:%.*]] = load float, ptr [[PTR1]], align 4
; SCALAR-NEXT:    store float [[LD2]], ptr [[PTR2]], align 4
; SCALAR-NEXT:    store float [[LD1]], ptr [[PTR1]], align 4
; SCALAR-NEXT:    ret void
;
  %ptr0 = getelementptr float, ptr %ptr, i32 0
  %ptr1 = getelementptr float, ptr %ptr, i32 1
  %ptr2 = getelementptr float, ptr %ptr, i32 2

  %ld0 = load float, ptr %ptr0
  store float %ld0, ptr %ptr0
  ; This call blocks scheduling of all 3 stores.
  call void @foo()

  %ld2 = load float, ptr %ptr2
  %ld1 = load float, ptr %ptr1
  store float %ld2, ptr %ptr2
  store float %ld1, ptr %ptr1
  ret void
}

; TODO: Vectorizing this requires trying out slices with gaps!
define void @slice_seeds3(ptr %ptr, float %val) {
;
; VECTOR-LABEL: define void @slice_seeds3(
; VECTOR-SAME: ptr [[PTR:%.*]], float [[VAL:%.*]]) {
; VECTOR-NEXT:    [[PTR0:%.*]] = getelementptr float, ptr [[PTR]], i32 0
; VECTOR-NEXT:    [[PTR1:%.*]] = getelementptr float, ptr [[PTR]], i32 1
; VECTOR-NEXT:    [[PTR2:%.*]] = getelementptr float, ptr [[PTR]], i32 2
; VECTOR-NEXT:    [[LD1:%.*]] = load float, ptr [[PTR1]], align 4
; VECTOR-NEXT:    store float [[LD1]], ptr [[PTR1]], align 4
; VECTOR-NEXT:    call void @foo()
; VECTOR-NEXT:    [[LD2:%.*]] = load float, ptr [[PTR2]], align 4
; VECTOR-NEXT:    [[LD0:%.*]] = load float, ptr [[PTR0]], align 4
; VECTOR-NEXT:    store float [[LD2]], ptr [[PTR2]], align 4
; VECTOR-NEXT:    store float [[LD0]], ptr [[PTR0]], align 4
; VECTOR-NEXT:    ret void
;
; SCALAR-LABEL: define void @slice_seeds3(
; SCALAR-SAME: ptr [[PTR:%.*]], float [[VAL:%.*]]) {
; SCALAR-NEXT:    [[PTR0:%.*]] = getelementptr float, ptr [[PTR]], i32 0
; SCALAR-NEXT:    [[PTR1:%.*]] = getelementptr float, ptr [[PTR]], i32 1
; SCALAR-NEXT:    [[PTR2:%.*]] = getelementptr float, ptr [[PTR]], i32 2
; SCALAR-NEXT:    [[LD1:%.*]] = load float, ptr [[PTR1]], align 4
; SCALAR-NEXT:    store float [[LD1]], ptr [[PTR1]], align 4
; SCALAR-NEXT:    call void @foo()
; SCALAR-NEXT:    [[LD2:%.*]] = load float, ptr [[PTR2]], align 4
; SCALAR-NEXT:    [[LD0:%.*]] = load float, ptr [[PTR0]], align 4
; SCALAR-NEXT:    store float [[LD2]], ptr [[PTR2]], align 4
; SCALAR-NEXT:    store float [[LD0]], ptr [[PTR0]], align 4
; SCALAR-NEXT:    ret void
;
  %ptr0 = getelementptr float, ptr %ptr, i32 0
  %ptr1 = getelementptr float, ptr %ptr, i32 1
  %ptr2 = getelementptr float, ptr %ptr, i32 2

  %ld1 = load float, ptr %ptr1
  store float %ld1, ptr %ptr1
  ; This call blocks scheduling of all 3 stores.
  call void @foo()

  %ld2 = load float, ptr %ptr2
  %ld0 = load float, ptr %ptr0
  store float %ld2, ptr %ptr2
  store float %ld0, ptr %ptr0
  ret void
}
