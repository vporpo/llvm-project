//===- SBRegion.h -------------------------------------------*- C++ -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#ifndef LLVM_TRANSFORMS_VECTORIZE_SANDBOXVEC_SBREGION_H
#define LLVM_TRANSFORMS_VECTORIZE_SANDBOXVEC_SBREGION_H

#include "llvm/ADT/SetVector.h"
#include "llvm/ADT/SmallVector.h"
#include "llvm/IR/Metadata.h"
#include "llvm/Support/raw_ostream.h"
#include "llvm/Transforms/Vectorize/SandboxVec/CostModel.h"
#include "llvm/Transforms/Vectorize/SandboxVec/InstrRange.h"
#include "llvm/Transforms/Vectorize/SandboxVec/Utils.h"
#include "llvm/Transforms/Vectorize/SandboxVec/SandboxIR.h"

namespace llvm {

/// The main job of the SBRegion is to point to new instructions generated by
/// vectorization passes. It is the unit that RegionPasses operate on with their
/// runOnRegion() function.
///
/// The region allows us to stack transformations horizontally, meaning that
/// each transformation operates on a single region and the resulting region is
/// the input to the next transformation, as opposed to vertically, which is the
/// common way of applying a transformation across the whole BB. This enables us
/// to check for profitability and decide whether we accept or rollback at a
/// region granularity, which is much better than doing this at the BB level.
///
/// The region keeps track of the costs that correspond to that region. That is
/// the original "scalar" cost and the new "vector" cost. The cost is updated
/// automatically via SandboxIR callbacks:
/// (i) Upon deletion: If the deleted instruction is not in the region, it is an
/// original scalar, so its cost is added to the "scalar cost", otherwise it is
/// a "vector" instruction created by the vectorizer so we subtract its cost
/// from the "vector cost".
/// (ii) Upon creation: New instructions are always considered "vector" so its
/// cost is added to the "vector cost".
/// This cost tracking allows us to start with transformations that may not be
/// profitable if applied by themselves, but may end up being profitable after a
/// series of transformations.
///
//  Traditional approach: transformations applied vertically for the whole BB
//    BB
//  +----+
//  |    |
//  |    |
//  |    | -> Transform1 ->  ... -> TransformN -> Check Cost
//  |    |
//  |    |
//  +----+
//
//  Region-based approach: transformations applied horizontally, for each Region
//    BB
//  +----+
//  |Rgn1| -> Transform1 ->  ... -> TransformN -> Check Cost
//  |    |
//  |Rgn2| -> Transform1 ->  ... -> TransformN -> Check Cost
//  |    |
//  |Rgn3| -> Transform1 ->  ... -> TransformN -> Check Cost
//  +----+

class SBRegion {
  /// This also includes the root.
  SetVector<SBValue *> Vectors;
  /// A unique ID, used for debugging.
  unsigned RegionID = 0;

  /// The top-level MDNode for this region.
  MDNode *RegionMDN = nullptr;
  /// This is used by the tracker verifier.
  SBBasicBlock &SBBB;

  SBContext &Ctxt;
  SBCostModel CM;

  InstructionCost ScalarCost;
  InstructionCost VectorCost;

  /// Called whenever a new instruction is added.
  SBContext::InsertCBTy *NewInstrCB = nullptr;
  /// Called when an instruction gets removed.
  SBContext::RemoveCBTy *RemInstrCB = nullptr;

  friend class SBRegionBuilderFromMD; // For addInstr()
  /// Creates the region's MDNode, or returns the already created one.
  MDNode *getOrCreateRegionMDN(LLVMContext &LLVMCtxt);

  void remove(SBInstruction *RemI);
  /// Removes all metadata that correspond to this region. Used explicitly by
  /// AcceptOrRevert pass.
  void dropMetadata();
  friend class SBRegionAttorney; // for dropMetadata().

public:
  static constexpr const char *MDKind = "sb";
  static constexpr const char *MDStrRegion = "region";
  static constexpr const char *MDStrNode = "node";

  // Top-Level region:             !0 = !{!"region", i32 0}
  static constexpr const int TLRegionStrOpIdx = 0;
  static constexpr const int TLRegionIDOpIdx = 1;

  explicit SBRegion(SBBasicBlock &SBBB, SBContext &Ctxt,
                     TargetTransformInfo &TTI);
  ~SBRegion();
  /// Used by the tracker verifier.
  SBBasicBlock *getParent() const { return &SBBB; }
  SBContext &getContext() const { return Ctxt; }
  /// \Returns the region's unique ID.
  unsigned getID() const { return RegionID; }
  void add(SBValue *V);

  using iterator = decltype(Vectors.begin());
  iterator begin() { return Vectors.begin(); }
  iterator end() { return Vectors.end(); }
  bool contains(SBInstruction *SBI) const {
    return Vectors.contains(SBI);
  }

  bool empty() const;

  InstructionCost getVectorMinusScalarCost() const;

#ifndef NDEBUG
  /// This is an expensive check, meant for testing.
  bool operator==(const SBRegion &Other) const;
  void dump(raw_ostream &OS) const;
  void dump() const;
  friend raw_ostream &operator<<(raw_ostream &OS, const SBRegion &Rgn) {
    Rgn.dump(OS);
    return OS;
  }

  static void unreachable(MDNode *MDN);
  static void verifyRegionMDN(MDNode *RgnMDN);
#endif // NDEBUG
};

/// A Client-Attorney class for SBRegion.
class SBRegionAttorney {
  friend class AcceptOrRevert;

public:
  static void dropMetadata(SBRegion &Rgn) { Rgn.dropMetadata(); }
};

class SBRegionBuilderFromMD {
  LLVMContext &LLVMCtxt;
  TargetTransformInfo &TTI;
  /// Goes through the relevant metadata of \p SBI and returns the MDNode of
  /// the region it belongs to.
  MDNode *getRegionMDN(SBInstruction *SBI) const;

public:
  SBRegionBuilderFromMD(SBContext &Ctxt, TargetTransformInfo &TTI);

  /// Scans \p SBBB for SBRegions and returns them.
  SmallVector<std::unique_ptr<SBRegion>>
  createRegionsFromMD(SBBasicBlock &SBBB);
};

} // namespace llvm
#endif // LLVM_TRANSFORMS_VECTORIZE_SANDBOXVEC_SBREGION_H
