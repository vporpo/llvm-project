//===- Region.h -------------------------------------------------*- C++ -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#ifndef LLVM_TRANSFORMS_VECTORIZE_SANDBOXVEC_REGION_H
#define LLVM_TRANSFORMS_VECTORIZE_SANDBOXVEC_REGION_H

#include "llvm/ADT/SetVector.h"
#include "llvm/ADT/SmallVector.h"
#include "llvm/IR/Metadata.h"
#include "llvm/Support/raw_ostream.h"
#include "llvm/Transforms/Vectorize/SandboxVec/CostModel.h"
#include "llvm/Transforms/Vectorize/SandboxVec/InstrInterval.h"
#include "llvm/SandboxIR/SandboxIR.h"

namespace llvm {
namespace sandboxir {

/// The main job of the Region is to point to new instructions generated by
/// vectorization passes. It is the unit that RegionPasses operate on with their
/// runOnRegion() function.
///
/// The region allows us to stack transformations horizontally, meaning that
/// each transformation operates on a single region and the resulting region is
/// the input to the next transformation, as opposed to vertically, which is the
/// common way of applying a transformation across the whole BB. This enables us
/// to check for profitability and decide whether we accept or rollback at a
/// region granularity, which is much better than doing this at the BB level.
///
/// The region keeps track of the costs that correspond to that region. That is
/// the original "scalar" cost and the new "vector" cost. The cost is updated
/// automatically via SandboxIR callbacks:
/// (i) Upon deletion: If the deleted instruction is not in the region, it is an
/// original scalar, so its cost is added to the "scalar cost", otherwise it is
/// a "vector" instruction created by the vectorizer so we subtract its cost
/// from the "vector cost".
/// (ii) Upon creation: New instructions are always considered "vector" so its
/// cost is added to the "vector cost".
/// This cost tracking allows us to start with transformations that may not be
/// profitable if applied by themselves, but may end up being profitable after a
/// series of transformations.
///
//  Traditional approach: transformations applied vertically for the whole BB
//    BB
//  +----+
//  |    |
//  |    |
//  |    | -> Transform1 ->  ... -> TransformN -> Check Cost
//  |    |
//  |    |
//  +----+
//
//  Region-based approach: transformations applied horizontally, for each Region
//    BB
//  +----+
//  |Rgn1| -> Transform1 ->  ... -> TransformN -> Check Cost
//  |    |
//  |Rgn2| -> Transform1 ->  ... -> TransformN -> Check Cost
//  |    |
//  |Rgn3| -> Transform1 ->  ... -> TransformN -> Check Cost
//  +----+

class Region {
  /// This also includes the root.
  SetVector<sandboxir::Value *> Vectors;
  /// A unique ID, used for debugging.
  unsigned RegionID = 0;

  /// The top-level MDNode for this region.
  MDNode *RegionMDN = nullptr;
  /// This is used by the tracker verifier.
  sandboxir::BasicBlock &SBBB;

  sandboxir::Context &Ctx;
  sandboxir::CostModel CM;

  InstructionCost ScalarCost;
  InstructionCost VectorCost;

  /// Called whenever a new instruction is added.
  sandboxir::Context::InsertCBTy *NewInstrCB = nullptr;
  /// Called when an instruction gets removed.
  sandboxir::Context::RemoveCBTy *RemInstrCB = nullptr;

  friend class RegionBuilderFromMD; // For addInstr()
  /// Creates the region's MDNode, or returns the already created one.
  MDNode *getOrCreateRegionMDN(LLVMContext &LLVMCtx);

  void remove(sandboxir::Instruction *RemI);
  /// Removes all metadata that correspond to this region. Used explicitly by
  /// AcceptOrRevert pass.
  void dropMetadata();
  friend class RegionAttorney; // for dropMetadata().

public:
  static constexpr const char *MDKind = "sb";
  static constexpr const char *MDStrRegion = "region";
  static constexpr const char *MDStrNode = "node";

  // Top-Level region:             !0 = !{!"region", i32 0}
  static constexpr const int TLRegionStrOpIdx = 0;
  static constexpr const int TLRegionIDOpIdx = 1;

  explicit Region(sandboxir::BasicBlock &SBBB, sandboxir::Context &Ctx,
                  TargetTransformInfo &TTI);
  ~Region();
  /// Used by the tracker verifier.
  sandboxir::BasicBlock *getParent() const { return &SBBB; }
  sandboxir::Context &getContext() const { return Ctx; }
  /// \Returns the region's unique ID.
  unsigned getID() const { return RegionID; }
  void add(sandboxir::Value *V);

  using iterator = decltype(Vectors.begin());
  iterator begin() { return Vectors.begin(); }
  iterator end() { return Vectors.end(); }
  bool contains(sandboxir::Instruction *SBI) const {
    return Vectors.contains(SBI);
  }

  bool empty() const;

  InstructionCost getVectorMinusScalarCost() const;

  sandboxir::BasicBlock *getBB() const { return &SBBB; }
#ifndef NDEBUG
  /// This is an expensive check, meant for testing.
  bool operator==(const sandboxir::Region &Other) const;
  void dump(raw_ostream &OS) const;
  void dump() const;
  friend raw_ostream &operator<<(raw_ostream &OS,
                                 const sandboxir::Region &Rgn) {
    Rgn.dump(OS);
    return OS;
  }

  static void unreachable(MDNode *MDN);
  static void verifyRegionMDN(MDNode *RgnMDN);
#endif // NDEBUG
};

/// A Client-Attorney class for sandboxir::Region.
class RegionAttorney {
  friend class AcceptOrRevert;

public:
  static void dropMetadata(sandboxir::Region &Rgn) { Rgn.dropMetadata(); }
};

class RegionBuilderFromMD {
  LLVMContext &LLVMCtx;
  TargetTransformInfo &TTI;
  /// Goes through the relevant metadata of \p SBI and returns the MDNode of
  /// the region it belongs to.
  MDNode *getRegionMDN(sandboxir::Instruction *SBI) const;

public:
  RegionBuilderFromMD(sandboxir::Context &Ctx, TargetTransformInfo &TTI);

  /// Scans \p SBBB for sandboxir::Regions and returns them.
  SmallVector<std::unique_ptr<sandboxir::Region>>
  createRegionsFromMD(sandboxir::BasicBlock &SBBB);
};

} // namespace sandboxir
} // namespace llvm
#endif // LLVM_TRANSFORMS_VECTORIZE_SANDBOXVEC_REGION_H
